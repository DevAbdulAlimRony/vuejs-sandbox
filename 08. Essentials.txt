Component Registering:
1. Global Component: When we register component in main.js.
2. We can make components available globally in the current Vue application using the .component() method. The
.component() method can be chained
3. Import locally where you will use like in App.vue defining components property
- can define component like component-name or ComponentName
- can use component in template like <component-name></component-name> or,
<ComponentName />
- components{component-name:ComponentName} or, components{ComponentName:ComponentName} or, components{ComponentName} -
vue detects all as same.
- If you globally register a component but end up not using it anywhere in your app, it will still be included in the
final bundle, that is problematic.
- Global registration makes dependency relationships less explicit in large applications, so local is better.
- Local registration makes the dependency relationship more explicit, and is more tree-shaking friendly.
- PascalCase is better for component names.

Scoped Styles:
1. If we write styling in any component, it affects all other components' template.
2.
<style scoped></style> : Scoped affects only that component's template.

Slot:
- Component have same markup structure and same style, the why duplicating code? use slot
- We can give name the slot, if one unnamed slot that will be default slot.
<slot></slot>
- Now use slot- <template v-slot="slotName"></template> , v-slot:default
- Vue give us a $slot property
- Shorthand for v-slot: #
- scoped slot: passing data from where you use the slot to where you pass the markup for the slot.

Dynamic Component
- which component to show?
-
<component :is="method"></component>
- keep alive component allows you to not remove the component entirely, but cached
- keep alive props: :include, :exclude, :max
- Keep alive lifecycle hook: onActivated(), onDeactivated()

-
<teleport to="body"></teleport> : Render it in the body element. Useful when we make modal with dialog.
- multiple teleport can be tragetted to same tag or class or id
- Teleport can be disabled by :disAbled='functionName'

- suspense for async(experimental)

- $ref attribute

// Lifecycle Hooks
// Each Vue component instance goes through a series of initialization steps.
// Vue runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.
// avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via
this if you do so.

- setup(): Called right after the instance is initialized, before data observation and event/watcher setup. Use
composition api in options api.
- beforeCreate(): Called right after the instance has been initialized, before data observation and event/watcher setup.
- created(): Called after the instance is created. At this stage, the instance has finished processing the options which
means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However,
the mounting phase has not been started, and the $el property will not be available yet.
- beforeMount(): Called right before the mounting begins: the render function is about to be called for the first time.
- mounted(): Called after the instance has been mounted, where el is replaced by the newly created. mounted hook can be
used to run code after the component has finished the initial rendering and created the DOM nodes
- beforeUpdate(): Called when data changes, before the DOM is patched and re-rendered.
- updated(): Called after a data change causes the virtual DOM to be re-rendered and patched
- beforeUnmount(): Called right before a component instance is unmounted.
- unmounted(): Called after a component instance has been unmounted.
- errorCaptured(): Called when an error from any descendent component is captured.
- renderTracked(): Called when a reactive dependency is tracked during render.
- renderTriggered(): Called when a reactive dependency causes a component to re-render.
- activated(): Called when a kept-alive component is activated.
- deactivated(): Called when a kept-alive component is deactivated.
- serverPrefetch(): Called when a component is server-side rendered.
- For Composition API:
- onBeforeMount()
- onMounted()
- onBeforeUpdate()
- onUpdated()
- onBeforeUnmount()
- onUnmounted()
- onActivated()
- onDeactivated()
- onServerPrefetch()
- onErrorCaptured()
- onRenderTracked()
- onRenderTriggered()
- We can use both Options API and Composition API lifecycle hooks in the same component.


// When a value is passed to a prop attribute, it becomes a property on that component instance.
// The value of that property is accessible within the template and on the component's this context.
// Props are reactive, so when the parent component's data changes, the prop value will be updated accordingly.
// :style="{ fontSize: postFontSize + 'em' }", postFontSize is the data here.
// Can call event emited by v-on or @

// Dynamically switch between components:
<component :is="currentTab"></component>
// the value passed to :is can be either a string (for globally or locally registered components) or a component object.
// You can also use the is attribute to create regular HTML elements.

// HTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase.
// PascalCase component names and camelCased prop names or v-on event names all need to use their kebab-cased
(hyphen-delimited) equivalents kebab-case in HTML
<blog-post post-title="hello!" @update-post="onUpdatePost"></blog-post>

// Can use Self closing Tag
/*<MyComponent />

// Some HTML elements, such as <ul>, <ol>, <table> and <select> have restrictions on what elements can appear inside them, and some elements such as <li>, <tr>, and <option> can only appear inside certain other elements.
// will be hoisted out as invalid content, causing errors in the eventual rendered output. 


// Template Ref: Sometimes we need direct access to the underlying DOM elements.
- We can use the ref attribute to register a reference to an element or a child component.
- We can access the element or component using this.$refs inside the component instance.
- The ref attribute can be used on any element or component in the template.
- When used on an element, this.$refs will return the corresponding DOM element.
- ref is a special attribute, similar to the key attribute discussed in the v-for
- It allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted.
//  <input ref="input" />
//  mounted() { this.$refs.input.focus() }
// The referenced instance will be identical to the child component's this, which means the parent component will have full access to every property and method of the child component. 
// The expose option can be used to limit the access to a child instance: expose: ['publicData', 'publicMethod'], now access child comps only those data and method using refs.
// When ref is used inside v-for, the resulting ref value will be an array 
// Instead of a string key, the ref attribute can also be bound to a function: input :ref="(el) => { /* assign el to a property or ref */ }">

// Watcher:
// There are cases where we need to perform "side effects" in reaction to state changes.
// With the Options API, we can use the watch option to trigger a function whenever a reactive property changes.
// toChange(newValue, oldValue). Also support dot-delimeted path: 'some.nested.key'(newValue). If one argument passed, its newValue. If two passed, first one is newValue, second one is oldValue.
// watch is shallow by default: the callback will only trigger when the watched property has been assigned a new value. it won't trigger on nested property changes.
// Deep Watchers: If you want the callback to fire on all nested mutations, you need to use a deep watcher.
// toChange: { handler(newValue, oldValue) {}, deep: true}
// The deep option can also be a number indicating the max traversal depth, how many levels should Vue traverse an object's nested properties.
// watch is lazy by default, won't be called until the watched source has changed.
// But sometimes we need eager like fetch some initial data and refetch when state changes.
// toChange: { handler(newValue){ //Run when comp created and when state changed }, immediate: true }
// Once Watcher: If you want the callback to trigger only once when the source changes, use the once: true option.
// Sometimes we do side effects in watcher. id(newId){async fetch(`/api/${newId}`).then(() => {},  what if id changes before the request completes?
// We can use the onWatcherCleanup() API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run.
// import { onWatcherCleanup } from 'vue', id(newId){fetch() onWatcherCleanup() () => {} onCleanup(()=> {})}, must be called during the synchronous execution
// Alternatively, an onCleanup function is also passed to watcher callbacks as the 3rd argument.
// If you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post' option. Ex- scroll to that content what changed after rendering new DOM.
// It's also possible to create a watcher that fires synchronously, flush:sync. Ex. if end date selected less thatn start date, immediately make it selected start date.
// We can create watcher using this.$watch() also.  created() { this.$watch('question', (newQuestion) => {
// Watcher stop when component unmount. But in rare case, if you wanna stop it, const unwatch = this.$watch('foo', callback), unwatch(). Ex- unwatched a route query param after fetch data.


// Form Input Bindings:
// <input :value="text" @input="event => text = event.target.value">, Replace it By: <input v-model="text" />
// Can used on v-select or textarea etc., vue will automatically expands to main DOM.
// We can use multiple checkboxes of same array v-model. So for Radio Button.
// For radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox)
// But sometimes we need to bind another type- :true-value="dynamicTrueValue", :false-value="dynamicFalseValue", :value="" in checkbox. true value false value only for vue's v-model
// v-model.lazy modiefier: Synced after "change" instead of "input". Ex- while Updating dependent fields.
// <input v-model.lazy="searchTerm" placeholder="Search..." />, Now API call fires ONLY when user finishes typing and leaves input.
// v-model.number: Automatically type cast the user input as number.
// v-model.trim: whitespace from user input to be trimmed automatically.


// Event Handling:
// v-on:click="handler". shortcut: @click="handler"
// <button @click="greet">Greet</button>
// we are able to access the element dispatching the event via event.target
// We can use inline handling, handling by method, method with argument.
// Access Event Argument: @click="warn('Form cannot be submitted yet.', $event)
// using inline arrow function: @click="(event) => warn('Form cannot be submitted yet.', event)"
// warn(message, event) { if (event) { event.preventDefault()....}}
// .stop event modifier: the click event's propagation will be stopped. When clicking a child button shouldnâ€™t trigger the parent click event like if click dialog content it wont close.
// .prevent event modifier: the submit event will no longer reload the page
// .self event modifier: only trigger handler if event.target is the element itself, not the child. same xmp of dialog.
// .capture event modifier: an event targeting an inner element is handled, Event captured first on parent, then on children.
// .once event modifier: the click event will be triggered at most once 
// .passive event modifier:  the scroll event's default behavior (scrolling) will happen, immediately, instead of waiting for `onScroll` to complete, This lets browser optimize scrolling for smoother performance.
// Modifiers can be chained: <a @click.stop.prevent="doThat"></a>
// just the modifier: <form @submit.prevent></form>
// Key Modifiers: When listening for keyboard events, we often need to check for specific keys.
// @keyup.enter="submit"
// You can directly use any valid key names exposed via KeyboardEvent.key: <input @keyup.page-down="onPageDown" />
// Key aliases: .enter, .tab, .delete (both dlt and backspace key), .esc, .space, .up, .down, .left, .right
// System modifier keys: .ctrl, .alt, .shift, .meta
//  Alt + Enter: <input @keyup.alt.enter="clear" />
// Ctrl/Alt/Shift + Click: @click.ctrl
// Only Ctrl + click: @click.ctrl.exact
// @click.exact: work for only click. If you alt + click - wont work. But for normal @click, any key with click will consider as just the click.
// Mouse Button Modifiers: .left, .right, .middle

// List Rendering:
// We can use the v-for directive to render a list of items based on an array.
// <li v-for="item in items">{{ item.message }}</li>
// items is the source data array and item is an alias for the array element being iterated on
// v-for also supports an optional second alias for the index of the current item
// v-for="(item, index) in items"
// Deconstruction: v-for="{ message } in items", v-for="({ message }, index) in items"
// Nested: <li v-for="item in items"> <span v-for="childItem in item.children">
// Can use of delimiter instead of in: <div v-for="item of items"></div>, no difference, just js style syntax.
// We can also iterate throgh the properties of object using v-for in similar way. can provide key: v-for="(value, key) in myObject"
// Another for the index: v-for="(value, key, index) in myObject"
// With a Range or Integer: v-for="n in 10"
// Can use on Template Tag: <template v-for="item in items">
// v-for and v-if cant exist together, because v-if has higher priority, and condition will be on item of loop. We can take a template for v-for then call v-if in the list.
// Use key- v-for="item in items" :key="item.id": To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements
// It is recommended to provide a key attribute with v-for whenever possible, unless the iterated DOM content is simple .
// We can use v-for on a custom component, must use key.
// <MyComponent  v-for="(item, index) in items" :item="item" :index="index" :key="item.id" />
// Array Mutation Methods(Replace original Array): push(), pop(), shift(), unshift(), splice(), sorft(), reverse().
// Non mutative, returns a new array: filter(), concat(), slice()
// If need to show sorted or filtered , use computed: return this.numbers.filter(n => n % 2 === 0)
// If nested where computed is not feasible, can use method.
// While using sort and reverse it will mutate the original array, so create copy and return: return [...numbers].reverse()
// As Js Callback: items.forEach((item, index) => { })

// Conditional Rendering:
// v-if, v-else-if, v-else.
// v-show: will always be rendered and remain in the DOM; v-show only toggles the display CSS property of the element.
// v-show doesn't support the <template> element, nor does it work with v-else.
// v-if is "real" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.
// v-if is also lazy: if the condition is false on initial render, it will not do anything
// v-if has higher toggle costs while v-show has higher initial render costs.
// Prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.

// Class Attribute Binding:
// We can pass an object to :class.
// v-bind:class or shortly :class. <div :class="{ active: isActive }"></div>
// Can use staic class and dynamic class together in an element
// We can also bind to a computed property that returns an object. This is a common and powerful pattern.
// classObject() { return { active: this.isActive && !this.error, 'text-danger': this.error }}, <div :class="classObject"></div>
// Binding to Arrays: :class="[activeClass, errorClass]"
// <div :class="[isActive ? activeClass : '', errorClass]"></div>
// We can use object syntax inside the array syntax: :class="[{ [activeClass]: isActive }, errorClass]"
// If in child component single root element, We can define class in child and parent- they will be merged.
// If multiple root element, we can define who will recieve the class of parent calling: <p :class="$attrs.class">Hi!</p>

// Style Attribute Binding:
// Same rules as Class
// Although camelCase keys are recommended, :style also supports kebab-cased CSS
// :style="{ 'font-size': fontSize + 'px' }"
// We can define a styleObject in data and then bind it- its a good idea.
// We can also take from computed property.
// We can bind :style to an array of multiple style objects.
// CSS property that requires a vendor prefix in :style, Vue will automatically add the appropriate prefix.
// Vue does this by checking at runtime to see which style properties are supported in the current browser.
// Providing Multiple Values using array: :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }" 